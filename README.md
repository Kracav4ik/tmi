# Turing-complete Machine Implementation

## составляющие компоненты
* вычислитель
  * кнопка запуска программы
  * 8ми битный счетчик для подсчета скобок для while
  * выставление команды, передаваемой в шину, происходит на заднем фронте (CLK 1 -> 0)
  * инициализация ячеек перед выполнением программы:
    * INIT0: начальное состояние сразу после включения
    * INIT1: выставить команду reset
    * INIT2: включить флаг активности и отослать тактовый импульс в шину
    * INIT3: выставить команду activate right
    * INIT4: отослать тактовый импульс в шину
    * INIT5: выключить флаг активности и выставить 000 в качестве текущей команды
    * RDY: состояние готовности к исполнению команды
  * ST_XXX - константы состояний
  * IS XXX - 1 если находимся в состоянии ХХХ
  * IS XXX CMD - 1 если текущая команда это ХХХ CMD
  * EXEC: отослать тактовый импульс в шину (простые команды)
  * EXECR: отослать тактовый импульс в шину (чтение из ячейки)
  * EXECW0: ждать пока в буфере клавиатуры не появится символ
  * EXECW1: отослать тактовый импульс в шину, удалить символ из буфера клавиатуры (запись в ячейку)
  * NEXT: попросить следующую команду из ленты
  * SHOW: вывести значение из активной ячейки на экран
  * WHGET: отослать тактовый импульс в шину (простые команды)
  * WHCHK: выбирает в какое состояние перейти в зависимости от значения в ячейке
  * SKIP: проматывает вперед правильную скобочную последовательность и встает после закрывающей скобки
  * JMP: проматывает назад правильную скобочную последовательность и встает на открывающую скобку
  * STOP: полная оствновка программы до перезапуска
  * переходы:
    * RDY -> EXEC - если произошел такт и команда на ленте простая команда
    * RDY -> EXECR - если произошел такт и команда на ленте команда вывода (out)
    * EXEC -> NEXT - если произошел такт
    * EXECR -> SHOW - если произошел такт
    * SHOW -> NEXT - если произошел такт
    * RDY -> EXECW0 - если произошел такт и в буфере клавиатуры нет символа
    * RDY -> EXECW1 - если произошел такт и в буфере клавиатуры есть символ
    * EXECW0 -> EXECW1 - если произошел такт и в буфере клавиатуры появился новый символ
    * EXECW1 -> NEXT - если произошел такт
    * RDY -> WHGET - если произошел такт и команда на ленте while (`[`), также выставляется команда чтение
    * RDY -> JMP - если произошел такт и команда на ленте jump (`]`)
    * WHGET -> WHCHK - если произошел такт
    * WHCHK -> SKIP - если произошел такт и считанное значение равно 0
    * WHCHK -> NEXT - если произошел такт и считанное значение не равно 0
    * SKIP -> NEXT - если произошел такт и счетчик скобочной последовательности равен нулю
    * JMP -> RDY - если произошел такт и счетчик скобочной последовательности равен нулю
  * простые команды (SIMPLE CMD): left, right, inc, dec
  * переключение состояний: на переднем фронте такта (когда сигнал меняется с 0 на 1) подготавливается значение состояния, на заднем фронте такта (с 1 на 0 соответственно) подготовленное значение записывается в текущее значение состояния
* цепочка элементарных ячеек
  * блок памяти (используем Счетчик 8 бит)
  * контакты слева
    * out сигнал соседу слева что он не хвост
    * in сигнал от соседа слева что мы не голова
    * out свой флаг активности
    * in флаг активности соседа слева
    * вход сквозной шины данных IN (8 бит)
    * выход сквозной шины данных OUT (8 бит)
    * вход сквозной шины команд (3 бита)
    * сквозной тактовый вход
  * контакты справа
    * in сигнал от соседа справа что мы не хвост
    * out сигнал соседу справа что он не голова
    * in флаг активности соседа справа
    * out свой флаг активности
    * выход сквозной шины данных IN (8 бит)
    * вход сквозной шины данных OUT (8 бит)
    * выход сквозной шины команд (3 бита)
    * сквозной тактовый выход
  * отладочные контакты снизу
    * содержимое счетчика (8 бит)
    * индикаторы (3 бита): голова, флаг активности, хвост
  * команды:
    * 0 0 0 игнорируется
    * 0 0 1 reset
    * 0 1 0 activate left
    * 0 1 1 activate right
    * 1 0 0 read
    * 1 0 1 write
    * 1 1 0 inc
    * 1 1 1 dec
  * смена активности происходит на заднем фронте (CLK 1 -> 0), все остальные команды на переднем фронте (CLK 0 -> 1)
* устройство с лентой команд
  * может проматывать ленту вперед и назад на одну команду
  * кадр перфоленты из 4х битов
  * симулирует перфоленту при помощи ПЗУ с 12-битным адресом и 4-битными данными
  * начинает с адреса 0x000 подключенного ПЗУ
  * команды:
    * jump  ] 0 0 0 0
    * while [ 0 0 0 1
    * left  < 0 0 1 0
    * right > 0 0 1 1
    * out   . 0 1 0 0
    * in    , 0 1 0 1
    * inc   + 0 1 1 0
    * dec   - 0 1 1 1
    * end     1 0 0 0
* устройство ввода (клавиатура)
  * неактивно пока не поступает команда на инпут
  * показывает, что нужен инпут и отображает введенный символ
* устройство вывода (пишущая машинка)
  * печатает символы как пишущая машинка
  * работает перевод строки (\n)
  * таб заменяет на пробел
  * остальные управляющие символы (например \r) не работают
